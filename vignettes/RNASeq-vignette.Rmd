---
title: 'RNA-seq vignette: dimensionality reduction with omicsGMF'
author:
- name: Alexandre Segers
bibliography: sgdGMF.bib
date: "14/01/2025"
output: 
  BiocStyle::html_document:
    toc: true
    toc_depth: 3
  BiocStyle::pdf_document: default
package: omicsGMF
abstract: |
  RNA-seq vignette for the omicsGMF package. This vignette aims to provide a 
  detailed description of a matrix factorization on RNA-seq, which can
  be used for dimensionality reduction and visualization of RNA-seq data.
vignette: >
  %\VignetteIndexEntry{RNASeq-vignette: omicsGMF}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
```{r, echo = FALSE}
library(knitr)
```

# Introduction

`omicsGMF` is an R package to perform generalized matrix factorization and 
imputation of missing values, and
can be used for dimensionality reduction and visualization of omics data.
It deals with count data and missing values in 
a fast way, and therefore does not require log-transformation of RNA-seq data 
or prior imputation of proteomics data, such as conventional PCA. Further, it 
can control for known sample- and feature covariates, and can therefore
account for the variability of for example batch effects, which helps
downstream analyses such as clustering. Also, `omicsGMF`
allows for model selection to optimize the 
number of latent confounders, i.e. the dimensionality of the reduced space. 
In conclusion, `omicsGMF` serves as an alternative to PCA 
when dealing with count or incomplete data and (technical) confounders while 
remaining fast due to its stochastic optimization algorithms.

`omicsGMF` builds on the `sgdGMF` framework provided in the `sgdGMF` CRAN 
package, but provides easy functions for `SingleCellExperiment`, 
`SummarizedExperiment`,
and `QFeature` classes, with adapted default values for the optimization 
parameters when dealing with omics data.

All details about the `sgdGMF` framework, such as the adaptive learning rates,
exponential gradient averaging and subsampling of the data are 
described in our preprint [@Castiglione2024]. There, we show the use of the
`sgdGMF-framework` on single-cell RNA-seq data. In our newest preprint 
[@Segers2025], we show how `omicsGMF` can be used to visualize (single-cell) 
proteomics data and impute missing values.

In this vignette, we show how `omicsGMF` can be easily used to obtain the
dimensionality reduction of omics data, while accounting for known 
confounders. Further, we show how it can visualize these samples based on
the dimensionality reduction. In total, there are four main functions:

1. `runCVGMF` or `calculateCVGMF` performs cross-validation to determine the 
optimal number of latent confounders. These results can be visualized using 
`plotCV`. This cross-validation avoids arbitrarily choosing `ncomponents`, but
requires some computational time. An alternative is `calculateRankGMF`, which
performs an eigenvalue decomposition on the deviance residuals. This allows for
model selection based on a scree plot using `plotRank`, for example using
the elbow method.

2. `runGMF` or `calculateGMF` estimates the latent confounders and the rotation
matrix, and estimates the respective parameters of the sample-level and 
feature-level covariates.

3. `plotGMF` plots the samples using its decomposition.

4. `imputeGMF` creates a new assay with missing values imputed using the 
estimates of `runGMF`.


We here show a standard workflow of `omicsGMF` on RNA-seq data.


# Package installation

`sgdGMF` can be installed through CRAN.
`omicsGMF` can be installed from Bioconductor with:

```{r, eval=FALSE}
if(!requireNamespace("sgdGMF", quietly = TRUE))
    install.packages("sgdGMF")

if(!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("omicsGMF")
```


```{r, echo = TRUE, warning=FALSE, message=FALSE}
library(sgdGMF)
library(omicsGMF)
library(dplyr)
library(scuttle)
set.seed(100)
```


# RNA-seq analysis

To perform dimensionality reduction on RNA-seq data, one can use the original
count matrices, without normalizing or log-transforming the sequencing
counts to the Gaussian scale. By using `family = poisson()`, `omicsGMF` 
optimizes the dimensionality reduction with respect to the likelihood of the
Poisson family. Further, by including a known covariate matrix, X, `omicsGMF`
corrects for known confounders in the dimensionality reduction. 

First, we simulate a small dataset using the `scuttle` package. For sake of 
exposition, we will further account for the `Treatment` covariate from the 
`colData`. 

```{r}
example_sce <- mockSCE(ncells = 20, ngenes = 500)

X <- model.matrix(~Treatment, colData(example_sce))
```

A recommended step is to estimate the optimal dimensionality in the model
by using cross-validation. This cross-validation masks a proportion of the
values as missing, and tries to reconstruct these. Using the out-of-sample 
deviances, one can estimate the optimal dimensionality of the latent space.
This cross-validation can be done with the `runCVGMF` or `calculateCVGMF` 
function, which builds 
on the sgdgmf.cv function from the `sgdGMF` package. Although the 
`sgdGMF` framework allows great flexibility regarding the optimization 
algorithm, sensible default values are here introduced for omics data. One
should choose the correct distribution family (`family`), the number
of components in the dimensionality reduction for which the cross-validation is
run (`ncomponents`), and the known covariate matrices to account for 
(`X` and `Z`). Also, one should select the right assay that is used for
dimensionality reduction (`exprs_values` or `assay.type`). 

Visualization of the cross-validation results can be done using 
`plotCV`. In case that multiple cross-validation results are available in the 
`metadata`, it is possible to visualize these by giving all names of the 
metadata slots.

```{r}
example_sce <- runCVGMF(example_sce, 
                        X = X,
                        exprs_values="counts", 
                        family = poisson(), 
                        ncomponents = c(1:5),
                        ntop = 500)

metadata(example_sce)$cv_GMF %>% 
    group_by(ncomp) %>% 
    summarise(mean_dev = mean(dev),
              mean_aic = mean(aic),
              mean_bic = mean(bic),
              mean_mae = mean(mae),
              mean_mse = mean(mse))

plotCV(example_sce, name = "cv_GMF")

```


If data are very large, or when having no idea which range of cross-validation 
values to explore, one can also use a scree plot of the eigenvalues for model
selection. This approach uses PCA on the deviance residuals to obtain the
eigenvalues, which is an approximation to the real matrix factorization.
This can be done using `runRankGMF` or `calculateRankGMF` followed
by `plotRank` or `screeplot_rank` respectively. Note that now, the 
`maxcomp` parameter can be defined, which is the number of 
eigenvalues computed.

```{r}
example_sce <- runRankGMF(example_sce, 
                          X = X, 
                          exprs_values="counts", 
                          family = poisson(), 
                          maxcomp = 10,
                          ntop = 500)

plotRank(example_sce, maxcomp = 10)
```


After choosing the number of components to use in the final dimensionality
reduction, `runGMF` or `calculateGMF` can be used. Again, one should select the
distribution family (`family`), the dimensionality (`ncomponents`), 
the known covariate matrices to account for (`X` and `Z`) and the 
assay used (`exprs_values` or `assay.type`). Note that, differently compared to
`runPCA`, by default all features are used. If this is not wanted, one can 
for example choose the n most variable genes used with `ntop`. 
`runGMF` returns the dimensionality reduction in the `reducedDim` argument of 
the `SingleCellExperiment`. Additional information such as the `rotation` 
matrix, parameter estimates, the optimization history of `sgdGMF` framework 
and many more are available in the `attributes`. See `runGMF` for all 
outputs. 

```{r, results = 'hide'}
example_sce <- runGMF(example_sce, 
                      X = X, 
                      exprs_values="counts", 
                      family = poisson(), 
                      ncomponents = 3,
                      ntop = 500,
                      name = "GMF")

names(attributes(reducedDim(example_sce, type = "GMF")))
head(attr(reducedDim(example_sce, type = "GMF"), "rotation"))
tail(attr(reducedDim(example_sce, type = "GMF"), "trace"))

reducedDimNames(example_sce)
head(reducedDim(example_sce))
```

After computing the matrix factorization, one can visualize the results with 
functions from the `scater` package. For example, using `plotReducedDim`, 
one obtains a PCA plot, using the latent factors obtained by `omicsGMF`. The 
same plot can be obtained using the wrapper function `plotGMF`.

```{r}
plotReducedDim(example_sce, dimred = "GMF", colour_by = "Mutation_Status")
```



```{r}
sessionInfo()
```

