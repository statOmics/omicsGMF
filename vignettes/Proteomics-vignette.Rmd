---
title: 'Proteomics vignette: dimensionality reduction and imputation 
with omicsGMF'
author:
- name: Alexandre Segers
bibliography: sgdGMF.bib
date: "14/01/2025"
output: 
  BiocStyle::html_document:
    toc: true
    toc_depth: 3
  BiocStyle::pdf_document: default
package: omicsGMF
abstract: |
  Proteomics vignette for the omicsGMF package. This vignette aims to provide a 
  detailed description of a matrix factorization on proteomics data, 
  which can further be used for dimensionality reduction, visualization and 
  imputation of missing values.
vignette: >
  %\VignetteIndexEntry{Proteomics-vignette: omicsGMF}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
```{r, echo = FALSE}
library(knitr)
```

# Introduction

`omicsGMF` is an R package to perform generalized matrix factorization and 
imputation of missing values, and
can be used for dimensionality reduction and visualization of omics data.
It deals with count data and missing values in 
a fast way, and therefore does not require log-transformation of RNA-seq data 
or prior imputation of proteomics data, such as conventional PCA. Further, it 
can control for known sample- and feature covariates, and can therefore
account for the variability of for example batch effects, which helps
downstream analyses such as clustering. Also, `omicsGMF`
allows for model selection to optimize the 
number of latent confounders, i.e. the dimensionality of the reduced space. 
In conclusion, `omicsGMF` serves as an alternative to PCA 
when dealing with count or incomplete data and (technical) confounders while 
remaining fast due to its stochastic optimization algorithms.

`omicsGMF` builds on the `sgdGMF` framework provided in the `sgdGMF` CRAN 
package, but provides easy functions for `SingleCellExperiment`, 
`SummarizedExperiment`,
and `QFeature` classes, with adapted default values for the optimization 
parameters when dealing with omics data.

All details about the `sgdGMF` framework, such as the adaptive learning rates,
exponential gradient averaging and subsampling of the data are 
described in our preprint [@Castiglione2024]. There, we show the use of the
`sgdGMF-framework` on single-cell RNA-seq data. In our newest preprint 
[@Segers2025], we show how `omicsGMF` can be used to visualize (single-cell) 
proteomics data and impute missing values.

In this vignette, we show how `omicsGMF` can be easily used to obtain the
dimensionality reduction of omics data, while accounting for known 
confounders. Further, we show how it can visualize these samples based on
the dimensionality reduction. In total, there are four main functions:

1. `runCVGMF` or `calculateCVGMF` performs cross-validation to determine the 
optimal number of latent confounders. These results can be visualized using 
`plotCV`. This cross-validation avoids arbitrarily choosing `ncomponents`, but
requires some computational time. An alternative is `calculateRankGMF`, which
performs an eigenvalue decomposition on the deviance residuals. This allows for
model selection based on a scree plot using `plotRank`, for example using
the elbow method.

2. `runGMF` or `calculateGMF` estimates the latent confounders and the rotation
matrix, and estimates the respective parameters of the sample-level and 
feature-level covariates.

3. `plotGMF` plots the samples using its decomposition.

4. `imputeGMF` creates a new assay with missing values imputed using the 
estimates of `runGMF`.


We here show a standard workflow of `omicsGMF` on proteomics data.


# Package installation

`sgdGMF` can be installed through CRAN.
`omicsGMF` can be installed from Bioconductor with:

```{r, eval=FALSE}
if(!requireNamespace("sgdGMF", quietly = TRUE))
    install.packages("sgdGMF")

if(!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("omicsGMF")
```


```{r, echo = TRUE, warning=FALSE, message=FALSE}
library(sgdGMF)
library(omicsGMF)
library(dplyr)
library(scuttle)
set.seed(100)
```


# Proteomics data analysis

To perform dimensionality reduction on proteomics data, one can use the 
log-transformed intensities, which makes the data Gaussian distributed. 
Optionally, one can opt to perform normalization such as median-normalization,
although this is not required. 
For proteomics data, `family = gaussian()` should be used in the data analyis, 
and missing 
values should not be imputed prior to the matrix factorization. If the goal
is to impute missing values after matrix decomposition, one should include all
features in the analysis.

For the proteomics vignette, we will simulate some artificial Gaussian 
data, and introduce some missing values completely ad random.
We store the simulated intensities in the `logintensities` assay of a 
`SingleCellExperiment`. For sake of exposition, we also include a batch
effect in the `colData`.


```{r}
sim_intensities <- matrix(rnorm(n = 20*500, mean = 1, sd = 1),
                          ncol = 20)
NAs <- rbinom(n = prod(dim(sim_intensities)), size = 1, prob = 0.3) == 1
sim_intensities[NAs] <- NA

colnames(sim_intensities) <- paste0("S_", c(1:20))
rownames(sim_intensities) <-  paste0("G_", c(1:500))

example_sce <- SingleCellExperiment(
    assays = SimpleList("logintensities" = sim_intensities),
    colData = data.frame("Batch" = rep(c("Batch1", "Batch2"), each = 10)))

X <- model.matrix(~Batch, data = colData(example_sce))
```



A recommended step is to estimate the optimal dimensionality in the model
by using cross-validation. This cross-validation masks a proportion of the
values as missing, and tries to reconstruct these. Using the out-of-sample 
deviances, one can estimate the optimal dimensionality of the latent space.
This cross-validation can be done with the `runCVGMF` or `calculateCVGMF` 
function, which builds 
on the sgdgmf.cv function from the `sgdGMF` package. Although the 
`sgdGMF` framework allows great flexibility regarding the optimization 
algorithm, sensible default values are here introduced for omics data. One
should choose the correct distribution family (`family`), the number
of components in the dimensionality reduction for which the cross-validation is
run (`ncomponents`), and the known covariate matrices to account for 
(`X` and `Z`). Also, one should select the right assay that is used for
dimensionality reduction (`exprs_values` or `assay.type`). 


Visualization of the cross-validation results can be done using 
`plotCV`. In case that multiple cross-validation results are available in the 
`metadata`, it is possible to visualize these by giving all names of the 
metadata slots.


```{r}
example_sce <- runCVGMF(example_sce, 
                          X = X,
                          exprs_values="logintensities", 
                          family = gaussian(), 
                          ncomponents = c(1:5))

metadata(example_sce)$cv_GMF %>% 
    group_by(ncomp) %>% 
    summarise(mean_dev = mean(dev),
              mean_aic = mean(aic),
              mean_bic = mean(bic),
              mean_mae = mean(mae),
              mean_mse = mean(mse))

plotCV(example_sce, name = "cv_GMF")

```


If data are very large, or when having no idea which range of cross-validation 
values to explore, one can also use a scree plot of the eigenvalues for model
selection. This approach uses PCA on the deviance residuals to obtain the
eigenvalues, which is an approximation to the real matrix factorization. Also,
note that this method imputes missing values with the feature mean to construct
the scree plot. Using `runRankGMF` or `calculateRankGMF` followed
by `plotRank` or `screeplot_rank` respectively constructs this scree plot. 
Note that now, the `maxcomp` parameter can be defined, which is the number of 
eigenvalues computed. 


```{r}
example_sce <- runRankGMF(example_sce, 
                                    X = X, 
                                    exprs_values="logintensities", 
                                    family = gaussian(),
                                    maxcomp = 10)

plotRank(example_sce, maxcomp = 10)
```




After choosing the number of components to use in the final dimensionality
reduction, `runGMF` or `calculateGMF` can be used. Again, one should select the
distribution family (`family`), the dimensionality (`ncomponents`), 
the known covariate matrices to account for (`X` and `Z`) and the 
assay used (`exprs_values` or `assay.type`). Note that, differently compared to
`runPCA`, by default all features are used. If this is not wanted, one can 
for example choose the n most variable genes used with `ntop`. However,
when the goal is imputing missing values, all features should be used.
`runGMF` returns the dimensionality reduction in the `reducedDim` argument of 
the `SingleCellExperiment`. Additional information such as the `rotation` 
matrix, parameter estimates, the optimization history of `sgdGMF` framework 
and many more are available in the `attributes`. See `runGMF` for all 
outputs. 


```{r, results = 'hide'}
example_sce <- runGMF(example_sce, 
                      exprs_values="logintensities", 
                      family = gaussian(), 
                      ncomponents = 3,
                      name = "GMF")

names(attributes(reducedDim(example_sce, type = "GMF")))
head(attr(reducedDim(example_sce, type = "GMF"), "rotation"))
tail(attr(reducedDim(example_sce, type = "GMF"), "trace"))


reducedDimNames(example_sce)
head(reducedDim(example_sce, type = "GMF"))
```


After computing the matrix factorization, one can visualize the results with 
functions from the `scater` package. For example, using `plotReducedDim`, 
one obtains a PCA plot, using the latent factors obtained by `omicsGMF`. The 
same plot can be obtained using the wrapper function `plotGMF`.



```{r}
plotReducedDim(example_sce, dimred = "GMF", colour_by = "Batch")
```

Finally, it is possible to impute the missing values with the mean estimates. 
This can be done with the `imputeGMF` function:

```{r, results = 'hide'}
example_sce <- imputeGMF(example_sce, 
                         exprs_values = "logintensities", 
                         reducedDimName = "GMF",
                         name = "logintensities_imputed")


assay(example_sce,'logintensities')[1:5,1:5]
assay(example_sce,'logintensities_imputed')[1:5,1:5]
```


```{r}
sessionInfo()
```

